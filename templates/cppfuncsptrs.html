{% extends "base.html" %}
{% block content %}
<section class="odd">
  <h1>Основы С++. Функции. Указатели.</h1>
  <p>
    В С++, как в любом порядочном языке программирования, есть функции.
    Функции - это небольшие готовые блоки кода, которые можно вызывать с любыми
    подходящими аргументами в основном коде программы и в других функциях, включая
    её саму (это называется рекурсия). Кроме функций, в С++ есть и такая
    замечательная низкоуровневая вещь, как указатели. Всё это мы сегодня разберём.
  </p>
</section>
<section class="even">
  <h2>Функции</h2>
  <pre><code class="cpp">
type name(type1 arg1, type2 arg2...) {
    // Код
}
  </code></pre>
  <p>
    То, что вы видите сверху - шаблонная функция. Этот пример, скорее всего,
    является слишком абстрактным, чтобы хоть что-то из него уловить, так что
    попробуем посмотреть на более понятную функцию:
  </p>
  <pre><code class="cpp">
int sum(int a, int b) {
    return a + b;
}

int main() {
    int a, b;
    cin >> a >> b;
    cout << sum(a, b) << endl;
}
  </code></pre>
  <p>
    Эта функция принимает на вход 2 целочисленных значения и возвращает
    их сумму. Что значит возвращает? Это значит, что полученное значение окажется
    в том же месте кода, где изначально был вызов функции. Функция может
    принимать аргументы любых (ну или почти любых) типов.
  </p>
  <p>
    В функции может быть больше кода, чем одна строка. Кроме того, она
    может возвращать разные вещи (иметь несколько выражений return) в зависимости
    от разных условий:
  </p>
  <pre><code class="cpp">
bool is_odd(int a) {
    if (a % 2 == 1) {
        return true;
    } else {
        return false;
    }
}
  </code></pre>
  <p>
    Эта функция проверяет число а на чётность и вернёт true, если оно нечётное, и
    false, если оно чётное. Попробуем применить её на практике и выведем только
    чётные числа от 0 до 9:
  </p>
  <pre><code class="cpp">
int main() {
    for (int i=0; i < 10; i++) {
        if (!is_odd(i)) {
            cout << i << endl;
        }
    }
    return 0;
}
  </code></pre>
  <p>
    Как вы могли заметить, имя аргумента функции не должно совпадать с переданным
    аргументом в коде. Мы можем даже не создавать переменную, а просто подставить
    туда какую-то константу, например 10.
  </p>
  <p>
    Раз уж мы заговорили об именах переменных, следует упомянуть, что в функциях
    (как, кстати, и в циклах), используются локальные переменные - всё, что вы
    создали в теле функции, недоступно за её пределами и будет удалено, как только
    функция завершится. Правда, в отличие от циклов, функции не имеют доступа
    к другим переменным доступным в main - такие дела.
  </p>
  <p>
    А что, если функция ничего не возвращает? Она просто выполняет какую-то
    процедуру в вакууме, и не должна отдавать никакого отчёта программе?
    На этот случай существует void.
  </p>
  <pre><code class="cpp">
void greet_user(string name) {
    cout << "Hello, " << name << "!" << endl;
}

int main() {
    string name;
    cin >> name;
    greet_user(name);
    return 0;
}
  </code></pre>
  <p>
    Но и на этом не всё, у функций до сих остался нераскрытый потенциал. При желании,
    вместо использования локальных переменных в функцию можно передавать конкретный кусок
    памяти, и тогда у нас будет возможность менять значения переменных, лежащих в
    main (но одновременно с этим мы потеряем возможность использовать просто
    значения, не присвоенные переменным). Рассмотрим разницу на примере полезной
    функции swap, которая поменяет местами значения двух переменных:
  </p>
  <pre><code class="cpp">
void bad_swap(int a, int b) {
    // Эта функция принимает переменные по значению,
    // Она не будет работать, как мы того хотим
    int temp = b;
    b = a;
    a = temp;
}

void good_swap(int &a, int &b) {
    // Эта функция принимает переменные по ссылке,
    // Она сделает именно то, что мы хотим
    int temp = b;
    b = a;
    a = temp;
}

int main() {
    int num1 = 10, num2 = 5;
    cout << num1 << " " << num2 << endl;
    bad_swap(num1, num2);
    cout << num1 << " " << num2 << endl;
    good_swap(num1, num2);
    cout << num1 << " " << num2 << endl;
    return 0;
}
  </code></pre>
  <p>
    Если запустить этот код, то будет видно, что при абсолютно одинаковом коде
    эти функции совершают разные действия - первая меняет местами значения
    переменных только у себя, вторая же меняет их в main. Первый вид передачи
    аргументов называется передачей по значению (by value) - при такой
    передаче в функции создаётся копия переменной с тем же значением. Если же
    ставить амперсанд (&) перед именем переменной, она будет передаваться по
    ссылке - функция получит адрес переменной в памяти и будет взаимодействовать
    непосредственно с ним. Это, кроме всего прочего, означает, что не будет
    задействована дополнительная память - мы не копируем переменную, а работаем
    с ней напрямую. Поэтому такие вещи, как, например, строки, изменять которые
    вы не собираетесь, гораздо правильнее будет передавать по ссылке - на код
    это не повлияет, а вот памяти занимать будет меньше.
  </p>
  <p>
    Теперь давайте модифицируем нашу функцию good_swap таким образом, чтобы
    она поддерживала не только целые числа. Это можно сделать двумя способами:
    "перегрузить" функцию, создав функцию с таким же названием, но другим набором
    аргументов (больше/меньше аргументов, либо другие их типы), или использовать
    шаблон. Шаблон - это такая конструкция, которая позволит нам описать функцию один
    раз, и позволить компилятору перегрузить эту функцию для каждого типа, к которому
    мы её применим.
  </p>
  <pre><code class="cpp">
// Создаём шаблон, в котором имя подменяемого компилятором
// типа обозначается как type
template &lt;typename type&gt;
void good_swap(type &a, type &b) {  // Подставляем вместо int наш тип type
    type temp = b;
    b = a;
    a = b;
}
  </code></pre>
</section>
<section class="odd">
  <h2>Указатели</h2>
  <p>
    При обсуждении передачи аргументов по ссылке мы затронули такую тему, как
    расположение переменных в памяти. В С++ есть один крайне мощный инструмент,
    который позволяет хранить в переменной <i>адрес</i> другой переменной,
    а не её содержимое. Этот инструмент называется <i>указателем (pointer)</i>,
    потому что он <i>указывает</i> на конкретную ячейку памяти. Для создания
    указателя используются символ звёздочки, для получения адреса переменной -
    уже знакомый нам амперсанд.
  </p>
  <pre><code class="cpp">
int a = 10;
int *pointer;  // Создаём указатель типа int
pointer = &amp;а  // Извлекаем адрес а и присваиваем указателю
int *ptr = &amp;a // Как и с обычными переменными, можно объединить эти строки
  </code></pre>
  <p>
    Если мы попробуем вывести куда-нибудь указатель, то мы получим непосредственно
    адрес, который в нём хранится. Если же мы хотим посмотреть само значение,
    хранящееся в этом указателе, нам нужно его разименовать, поставив перед ним
    звёздочку:
  </p>
  <pre><code class="cpp">
cout << pointer << endl;
cout << *pointer << endl;
  </code></pre>
  <p>
    Сами по себе такие указатели не очень полезны, настоящая магия начинается,
    когда используется арифметика указателей. Так как указатель - это ячейка памяти,
    а все ячейки памяти пронумерованы, то мы можем просто взять, и сдвинуть его
    на одну длину его типа вперёд или назад:
  </p>
  <pre><code class="cpp">
cout << pointer << endl;
pointer++;  // Увеличиваем pointer на 1
// Т.к. мы не поставили звёздочку и не заключили pointer в скобки,
// вместо того, чтобы увеличить а на 1, мы увеличили адрес, хранимый в указателе
cout << pointer << endl;
  </code></pre>
  <p>
    Если запустить этот код, то разница в адресах будет равна четырём - это происходит
    из-за того, что указатели учитывают размер типа, на который они ссылаются. В нашем случае
    это тип int, который занимает (в x86) 4 байта, отсюда и адрес увеличивается на 4 байта.
    Возникает вопрос: можно ли взять несколько целых чисел, и записать их вплотную,
    чтобы не хранить каждую в переменной? Ответ: да, это называется массивом.
  </p>
</section>
<section class="even">
  <h2>Массивы</h2>
  <p>
    В С++ существует два типа массивов: статические и динамические. Разница простая:
    статический массив создаётся заранее и его длина известна ещё на этапе компиляции,
    тогда как динамический массив может иметь длину, заданную в процессе исполнения
    программы какими-либо вычислениями или, например, введённую пользователем.
  </p>
  <p>
    Статические массивы создаются почти также, как и переменные:
  </p>
  <pre><code class="cpp">
int array[10];
for (int i=0; i < 10; i++) {
    array[i] = i;  // Заполняем массив числами от 0 до 9
}
  </code></pre>
  <p>
    Вместо int можно подставить любой подходящий тип, а вместо 10 - любое другое число.
    При желании можно инициализировать массив прямо при создании:
  </p>
  <pre><code class="cpp">
int array[10] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
  </code></pre>
  <p>
    Стоит помнить, что в массивах индексация начинается с нуля - таким образом,
    первый элемент имеет индекс 0, четвёртый - 3, а последний - длина массива-1.
    Почему так? Ответ, опять-таки, прост. array - это не какой-то особенный класс
    или необычный объект, это просто указатель на первый элемент массива.
    Таким образом, следующие две записи абсолютно идентичны:
  </p>
  <pre><code class="cpp">
array[i];
*(array + i);
  </code></pre>
  <p>
    Здесь уже очевидно, что когда мы подставим 1, то мы уйдём с первого элемента
    (до которого ничего передвигать не надо, указатель уже на него ссылается) на
    второй и так далее.
  </p>
  <p>
    Статические массивы - это замечательно, но мы далеко не всегда можем знать
    длину массива в процессе написания программы. Что, если её вводит пользователь?
    В таком случае нам на выручку приходят динамические массивы. Для их создания
    используется оператор new:
  </p>
  <pre><code class="cpp">
int n;
cin >> n;  // Пользователь вводит длину массива
int *array = new int[n];
  </code></pre>
  <p>
    int можно заменить на любой нужный нам тип, array - на любое интересное
    имя переменной, а вместо n можно подставлять и готовые числа. Что же
    делает new? Выделяет нам кусок памяти, в который можно поместить
    <i>как минимум</i> n элементов типа int. Его противоположностью
    является delete, который помечает ячейку памяти, как пустую и позволяет
    выделить её вновь для другого массива или переменной. В идеальном коде, каждому
    new будет соответствовать delete, который будет выполняться как только
    массив теряет свою актуальность:
  </p>
  <pre><code class="cpp">
int *array = new int[n]; // Создали массив
...
delete[] array; // Удалили массив
  </code></pre>
  <p>
    Стоит отметить, что данные, которые лежали в массиве, всё ещё хранятся по этому
    адресу, но теперь наша программа имеет полное право начать записывать новые
    данные поверх старых.
  </p>
  <p>
    Одномерные массивы - штука крайне полезная, но не всегда удобная. Нередко
    бывают нужны матрицы - двумерные массивы, элементы которых имеют не просто
    индекс, а целых две координаты - номер строки и номер столбца. Иными словами,
    двумерный массив - это массив массивов, где каждый его элемент - это указатель
    на область памяти с числами.
  </p>
  <pre><code class="cpp">
int **matrix = new int*[n];
for (int i=0; i < n; i++) {
    matrix[i] = new int[m];
}
...
matrix[i][j];  // Элемент на i-ой строке в столбце j
...
for (int i=0; i < n; i++) {
    delete[] matrix[i];
}
delete[] matrix;
  </code></pre>
  <p>
    Почему перед matrix мы поставили 2 звездочки, да ещё и впихнули одну перед
    длиной массива? Потому что matrix - это массив массивов, т.е. указатель на
    указатели. Указатель на int записывается как *int, а указатель на указатель
    на int, соответственно - **int.
  </p>
</section>
<section class="odd">
  <h2>Практика</h2>
  <p>
    Традиционно применим полученные знания на практике для закрепления в памяти.
    В частности, напишем набор функций для создания и удаления массивов и матриц,
    а также для расширения массива до определённого размера.
  </p>
  <pre><code class="cpp">
#include &lt;iostream>

using namespace std;

template &lt;typename type>
type *create_array(int n) {
    return new type[n];
}

template &lt;typename type>
void delete_array(type *array) {
    delete[] array;
}

template &lt;typename type>
type **create_matrix(int n, int m) {
    type **matrix = create_array&lt;type*>(n);
    for (int i=0; i < n; i++) {
        matrix[i] = create_array&lt;type>(m);
    }
    return matrix;
}

template &lt;typename type>
void delete_matrix(type **matrix, int n) {
    for (int i=0; i < n; i++) {
        delete_array(matrix[i]);
    }
    delete_array(matrix);
}

template &lt;typename type>
void bubble_sort(type *&amp;array, int n) {
    for (int i=0; i < n-1; i++) {
        for (int j=0; j < n-1-i; j++) {
            if (array[j] > array[j+1]) {
                swap(array[j], array[j+1]);
            }
        }
    }
}

template &lt;typename type>
void extend_array(type *&amp;array, int size, int newsize) {
    type *copy = array;
    array = create_array&lt;type>(newsize);
    memcpy(array, copy, size * sizeof(type));
    delete_array(copy);
}

int main() {
    int n, m;
    cin >> n >> m;
    // Т.к. аргументы для создания матрицы не зависят от её типа,
    // нам нужно указать желаемый тип в &lt;таких скобках>
    double **matrix = create_matrix&lt;double>(n, m);
    for (int i=0; i < n; i++) {
        for (int j=0; j < m; j++) {
            cin >> matrix[i][j];
        }
        bubble_sort(matrix[i], m);
        for (int j=0; j < m; j++) {
            cout << matrix[i][j] << "\t";
        }
        cout << endl;
    }
    delete_matrix(matrix, n);
    cin >> n >> m;
    int *array = create_array&lt;int>(n);
    for (int i=0; i < n; i++) {
        cin >> array[i];
    }
    extend_array(array, n, m);
    for (int i=n; i < m; i++) {
        cin >> array[i];
    }
    for (int i=0; i < m; i++) {
        cout << array[i] << endl;
    }
    return 0;
}
  </code></pre>
  <p>
    Любую из этих функций можно скопировать в свою программу и благополучно
    там использовать, получив гораздо более чистый и простой для понимания код.
    Любопытствующие могут в качестве эксперимента написать функцию, которая
    будет получать на вход матрицу и два её размера, и возвращать
    одномерный массив со всеми элементами матрицы.
  </p>
</section>
{% endblock %}