{% extends "base.html" %}
{% block content %}
<section class="odd">
    <h1>Работа с потоками и файлами в С++</h1>
    <p>
        Как было сказано в одной из прошлых записей, на замену функциям printf и scanf из
        C, в С++ появились потоки cout и cin соответственно. У них есть ряд преимуществ,
        в том числе и возможность осуществления ввода-вывода данных в структуры, но об этом
        позже. На данный момент главным преимуществом потоков является их универсальность.
        Код, написанный для работы с консолью, путём сравнительно нехитрых действий можно
        превратить в код для работы с файлом. Вот это мы сегодня и рассмотрим.
    </p>
</section>
<section class="even">
    <h2>Определение потока</h2>
    <p>
        Ну так что же вообще такое "поток"? Поток - это интерфейс к "течению" данных,
        или иными словами - простой способ взаимодействия с каким-то их набором. Сравним его
        с пультом от телевизора - всё, что мы делаем - нажимаем на кнопку, уже сам пульт определяет,
        на какую кнопку мы нажали, и пересылает сигнал неизвестными нам путями в телевизор. Не важно,
        как он это делает, важно то, что мы нажали на кнопочку и получили результат. Если мы возьмём
        другой пульт или привяжем его к другому телевизору, то нажатие на ту же кнопку приведёт
        к тому же результату, хоть это и другая модель пульта/телевизора. У них может быть другое
        устройство, но действия с нашей стороны не изменились.
    </p>
    <p>
        Если же забыть про слово "интерфейс" и просто рассматривать поток, как доступ к "течению" данных,
        то его можно сравнить с рекой. В неё можно что-то вылить, и это что-то куда-то приплывёт; из неё
        также можно что-то вычерпнуть или выловить. Вода и мусор в реке - это данные, а река - это их поток.
    </p>
</section>
<section class="odd">
    <h2>Файловые потоки</h2>
    <p>
        Как уже было сказано, потоки бывают разные. Cout и cin - потоки, взаимодействующие с консолью.
        Но тут вдруг нам перестала нравиться консоль - она требует присутствия пользователя, вывод
        в неё исчезнет при её закрытии и вообще всё тлен. Вот захотелось положить куда-то информацию так,
        чтобы она оттуда никуда не делась. Для этого существуют файлы и соответствующие им потоки.
        Они импортируются из библиотеки &lt;fstream>.
    </p>
    <pre><code class="cpp">
#include &lt;fstream>

using namespace std;

int main() {
    ifstream fin;
    ofstream fout;
    return 0;
}
    </code></pre>
    <p>
        В приведённом выше коде мы объявили два файловых потока: поток ввода fin и поток вывода fout.
        Для этого мы создали переменные классов ifstream и ofstream. Почему эти классы так называются?
        stream - это поток, i/o - сокращение от input (ввод)/output (вывод) соответственно. f - сокращение от file.
        Потоки cout и cin являются объектами классов ostream и istream, без буквы f.
    </p>
    <p>
        Если мы попробуем что-то в эти потоки вывести, ничего толкового из этого не выйдет. Для начала
        нужно привязать эти потоки к файлу (или файлам, если мы будем получать данные из одного файла
        и переносить их в другой). Это осуществляется вызовом метода open:
    </p>
    <pre><code class="cpp">
fin.open("filename.ext");
    </code></pre>
    <p>
        Аргументом, передаваемым в функцию, является переменная типа string (или строковый литерал),
        содержащая путь до файла. Путь может быть как полным (C:\Users\...\File.ext), так и относительным
        (folder\file.ext). Относительный путь начинается из папки, в которой находится исполняемый .exe файл.
    </p>
    <p>
        При желании, можно открыть файл сразу при создании потока:
    </p>
    <pre><code class="cpp">
ifstream fin("filename.ext", ios::binary | ios::in);
    </code></pre>
    <p>
        Так, с открытием при объявлении всё понятно, а вот что за ересь внезапно появилась справа от адреса
        файла? Это модификаторы открытия, находящиеся в именном пространстве std::ios. Основные модификаторы:
    </p>
    <ul>
        <li>ios::in, ios::out - открытие на чтение/запись;</li>
        <li>ios::app - открытие на запись в конец;</li>
        <li>ios::ate - перевод каретки в конец файла (об этом позже);</li>
        <li>ios::trunc - "Обрезать" (truncate) файл до пустого при открытии (связано с тем, что удалять напрямую
        из файла нельзя - можно либо перезаписать байты, либо опустошить файл и записать новый поверх старого);</li>
        <li>ios::binary - открыть файл в двоичном режиме (чтение сухих двоичнх данных вместо работы с символами).</li>
    </ul>
    <p>
        Объединяются эти модификаторы путём проведения побитового умножения (одинарный символ |, почти как "или" (||)).
        Например, чтобы открыть файл на чтение и запись двоичных данных, мы напишем:
    </p>
    <pre><code class="cpp">
fstream file(path, ios::binary | ios::out | ios::in);
    </code></pre>
    <p>
        Никакой опечатки там нет, действительно создаётся объект класса fstream. Чем он отличается от ifstream
        и ofstream? В отличие от тех классов, этот не имеет ограничения на исключительно чтение/запись и может
        объединять эти операции; с другой стороны, он по умолчанию не подставляет никаких модификаторов, поэтому
        их всегда нужно прописать самостоятельно. ifstream подставляет ios::in, ofstream подставляет ios::out | ios::trunc.
    </p>
</section>
<section class="even">
    <h2>Положение каретки</h2>
    <p>
        При перечислении модификаторов была упомянута такая страшная вещь, как положение каретки. Что это вообще?
        Откройте любой текстовый редактор, блокнот например. Наберите какой-нибудь текст
        на несколько строк и кликните в случайное его место. Туда переместится мигающая палочка, или курсор.
        Вот этот курсор также называют кареткой - именно она определяет, куда вы будете вставлять символы. В файлах
        каретка определяет не только куда будут вставлены символы, но и откуда они будут читаться.
    </p>
    <p>
        Каждый раз, когда мы пишем/читаем один байт данных, поток автоматически сдвигает соответствующую каретку
        (их у него две, одна на запись (put, p), и одна на чтение (get, g)). Чтобы узнать текущее положение
        каретки, используется метод fstream.tell:
    </p>
    <pre><code class="cpp">
fstream file;
file.open(path);
cout << file.tellg() << endl; // Вывод положения каретки чтения
cout << file.tellp() << endl; // Вывод положения каретки записи
    </code></pre>
    <p>
        Если же мы знаем координаты нужного нам байта, можно вручную поменять положение каретки командой
        seek:
    </p>
    <pre><code class="cpp">
file.seekg(10);
file.seekp(20, ios::curr);
    </code></pre>
    <p>
        Так, а что это за второй аргумент появился? Это - модификатор точки отсчёта. Их три: ios::beg - сдвиг
        относительно начала (подставлен по умолчанию), ios::curr - сдвиг относительно текущего положения и ios::end -
        сдвиг относительно конца. Вот эти модификаторы объединять нельзя, они друг другу противоречат.
    </p>
</section>
<section class="odd">
    <h2>Символьные чтение и запись</h2>
    <p>
        Уйдём от абстракции и прочего мусора и поговорим о непосредственно записи и чтении. Как уже было сказано
        ранее, потоки - универсальны, и все они работают +- одинаково. Файловые потоки - не исключение.
    </p>
    <pre><code class="cpp">
file << "Some text that will go into the file" << endl;
string word;
file >> word;
    </code></pre>
    <p>
        Вспомним аналогию с блокнотом. Наберите ещё сколько-то строк текста, ткните куда-нибудь
        в середину файла и нажмите на insert. Вот так происходит запись из потока в файл:
        переданные символы не вставляются между существующими, удлинняя файл, а заменяют существующие,
        причём в отличие от блокнота, клавиши Backspace в потоке нет. Если размеры записи, которую необходимо
        изменить, совпадают с точностью до байта - можно передвинуть туда каретку и перезаписать её. Если
        же нужно удалить/вставить/изменить запись так, что её байтовая длина не совпадает с изменяемой - придётся
        считать файл в память, переоткрыть его с параметром trunc и записать заново, уже в скорректированном виде.
    </p>
    <p>
        Файловые потоки также работают с обеими версиями getline, как методом, работающим с символьным массивом,
        так и функцией из библиотеки &lt;string>. Они поддерживают получение и запись одного символа (file.get() и
        file.put()), пропуск символов file.ignore(), проверку на успешность чтения file.fail() и так далее. Точно
        также можно использовать функции setw, endl, вешать флаги и всё прочее.
    </p>
    <p>
        Иными словами, всё те принципы ввода/вывода, которые вы выучили для работы с консолью, будут работать
        аналогично и при работе с файлами, а некоторые из принципов работы с файлами можно перенести и на работу
        с консолью, но об этом в конце.
    </p>
</section>
<section class="even">
    <h2>Бинарные чтение и запись</h2>
    <p>
        Иногда возникает необходимость читать и писать данные в двоичном (бинарном) виде. У такого
        подхода есть ряд преимуществ по сравнению с символьной записью - бинарная запись занимает
        меньше места, не требует разделения символами пустого пространства (т.к. у типов чётко прописаны
        размеры), занимает меньше времени (пропускается этап конвертирования записи, понятной человеку, в запись
        с тем же смыслом, понятную компьютеру) и тому подобное. Но есть и один достаточно жирный минус, и имя
        этому минусу - способ записи. Этот способ записи - не просто минус, а целая балка, которая стоит чуть
        выше уровня головы в дверном проёме программирования и оставляет на память огромную шишку.
    </p>
    <p>
        Разберёмся, в чём же проблема. Операторы << и >> осуществляют работу исключительно с символами -
        они извлекают из потока символы и конвертируют их в числа/строки/ещё что-нибудь, либо конвертируют
        это самое что-то из двоичного кода в символы. Если же мы захотим записать сырые двоичные данные,
        нам придётся использовать методы file.write и file.read. Эти методы принимают на вход два аргумента:
        указатель на то, <i>откуда</i> брать байты для чтения/записи, и <i>сколько</i> байтов брать. Вроде несложно,
        так ведь? Извлекаем адрес из переменной амперсандом, вычисляем размер её типа функцией sizeof, и
        всё, не правда ли? А вот неправда. Эти методы принимают не просто указатель на то, откуда брать байты,
        а указатель на тип char. Почему именно char? Потому что он всегда занимает ровно 1 байт, а 1 байт - это,
        по совместительству, минимально адресуемая ячейка памяти. Таким образом, передав указатель на char,
        мы передали в функцию массив байтов. Вычислив размер типа, мы передали размер массива.
    </p>
    <p>
        Я надеюсь, что это было несложно понять, потому что сейчас пойдёт речь о приведении типов.
        Есть два стиля приведения типов: С-подобное приведение (которое следует избегать), и приведение из
        С++. Что вообще такое приведение типов? Это процесс перевода переменной из одного типа в другой.
        Например, если мы хотим получить полноценный результат от деления двух целочисленных переменных,
        без потери дробной части, нам необходимо превратить одну из них в double. Для этого используется
        static_cast - функция приведения, которая именно конвертирует переданное значение в другой тип:
    </p>
    <pre><code class="cpp">
int a = 10;
int b = 3;
cout << a / b << endl;  // Целочисленное деление
cout << static_cast&lt;double>(a) / b << endl;  // Полноценное деление
    </code></pre>
    <p>
        Такой шаблон мы уже рассматривали в статье о функциях. В угловых скобках передаётся тип,
        в который мы собираемся конвертировать значение. В данном случае, 10 дополняется (расширяется) до
        типа double - создаётся такое значение типа double, числовое представление которого будет
        полностью (или почти полностью) идентично таковому от a. Сама переменная а и значение, записанное
        в ней, остались неизменны.
    </p>
    <p>
        Обратную операцию (статическое приведение из double в int) можно совершить, но скорее всего IDE
        предупредит вас о том, что вы пытаетесь совершить сужающуюся конверсию типов - т.е. есть риск потерять
        часть значения при конвертации.
    </p>
    <p>
        Это - статическое приведение типов, нам оно не поможет - если мы попытаемся превратить, например,
        int в char, то мы просто переполним разрядную сетку и получим мало связанное с реальностью число.
        Вместо этого нам нужно просто сделать вид, что эти байты - это на самом деле ни разу не int, а 4 char-а.
        Для этого используется самый опасный из вариантов приведения типов - reinterpret_cast. Фактически, мы так
        и говорим процессору: "Эй, помнишь я взял адрес от int-овой переменной? Так вот, с этих пор это указатель
        на char, смирись с этим". Запишем это в коде:
    </p>
    <pre><code class="cpp">
reinterpret_cast&lt;char*>(&variable);
    </code></pre>
    <p>
        (Отметим, что если мы будем пытаться записать в файл массив данных, извлекать адрес больше не нужно).
    </p>
    <p>
        Выглядит это всё куда страшнее, чем это есть на самом деле. Таким образом, чтобы
        записать, например, число 30.5 в файл в двоичном виде, а затем это же число прочитать, мы напишем:
    </p>
    <pre><code class="cpp">
double var = 30.5;
file.write(reinterpret_cast&lt;char*>(&var), sizeof(double));
...
double othervar;
file.read(reinterpret_cast<&lt;char*>(&othervar), sizeof(double));
    </code></pre>
    <p>
        Да, кстати, если вы попробуете открыть такой файл блокнотом или другим текстовым редактором,
        то вы увидите много пустого пространства и случайных странных символов - так и должно быть, потому
        что храним мы не символы.
    </p>
    <p>
        Для любознательных: приведение типов из C, при котором мы просто записываем в скобках тип, в который
        мы хотим перевести переменную, следует избегать по одной простой причине: его поведение неочевидно.
        Это называется неявным приведением типа, и в сравнении с явным приведением оно заметно проигрывает по двум
        причинам: во-первых, оно менее безопасно - вместо того, чтобы попробовать один конкретный вид приведения,
        нужный нам, неявное приведение будет пытаться провернуть каждое из видов приведения по очереди, пока у него
        что-то не выйдет; во-вторых, найти такое приведение через Ctrl+F сложнее, чем оформленное как
        somekindof_cast&lt;type>.
    </p>
</section>
<section class="odd">
    <h2>Конец файла</h2>
    <p>
        Далеко не всегда нам заранее известно, какой длины файл и сколько из него можно считать всяких интересностей.
        Наша программа, будучи увлечённой процессом, может запросто вылететь за границу файла. Чтобы такого не
        произошло, в потоках есть такая вещь, как флаг EOF (End Of File). Его состояние можно посмотреть, вызвав
        одноимённый метод file.eof(). Если он вернул true, то конец файла был достигнут и любая попытка
        что-нибудь вывести в файл или считать из него закончится целым ничем, а попытка узнать положение каретки
        вернёт -1. Это можно использовать в качестве условия для цикла while. Разберём это на примере чтения
        двоичного массива данных из файла, доступ к которому реализован в потоке fin, и копировании этих
        значений в символьном виде в файл, привязанный к потоку fout:
    </p>
    <pre><code class="cpp">
while (!fin.eof()) {
    int a;
    fin.read(reinterpret_cast&lt;char*>(&a), sizeof(int));
    if (!fin.fail()) {
        fout << a << " ";
    }
}
    </code></pre>
    <p>
        Пока мы не наткнёмся на конец файла, мы будем копировать все числа из потока fin в переменную
        a и тут же перекидывать их в поток fout, при условии, что мы смогли их прочитать (fin.fail() даёт
        true, если при чтении произошла какая-то ошибка, и значение переменной осталось таким же, как до
        вызова функции).
    </p>
    <p>
        Если мы хотим продолжить работу с файлом после достижения его конца, но не хотим открывать
        его заново, можно использовать метод file.clear() - он очистит все установленные флаги, в том
        числе и eof, и позволит продолжить работу с файлом.
    </p>
</section>
<section class="even">
    <h2>Завершение работы</h2>
    <p>
        Когда файл больше не представляет для нас интереса, или же мы вообще заканчиваем работу с
        программой, его следует закрыть, чтобы позволить другим процессам пользоваться этим файлом.
        Для этого используется метод file.close(). Проверить, открыт ли какой-либо файл в потоке на данный
        момент, можно с помощью метода file.is_open(). По-хорошему, это нужно проверять каждый раз, когда мы
        открываем файл, потому что он мог не открыться (по разным причинам - его не существует и выбранный
        набор параметров не подразумевает создание файла, файл используется другой программой, файловая
        система решила быкануть, etc.) Закрытие аналогично по своей сути удалению массива, только в отличие от массива
        мы не освобождаем память - данные всё ещё лежали на жёстком диске, мы лишь освободили их и позволили
        другим процессам ими пользоваться. Но общий принцип (каждому new должен соответствовать delete, каждому
        open - close) соблюдается.
    </p>
</section>
{% endblock %}