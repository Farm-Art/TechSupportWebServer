{% exentds "base.html" %}
{% block content %}
<section class="odd">
  <h1>Структуры и списки</h1>
  <p>
    Одной из ключевых особенностей C++ стала поддержка ООП, или объекто-ориентированного
    программирования. Концепт ООП построен на создании экземпляров (instances) различных
    классов, каждый из которых имеет набор членов (members) - полей-аттрибутов
    и методов. Существует ряд ключевых механизмов, таких как наследование и
    полиморфизм, но все эти темы пока изучать рано. Начать стоит с самых основ,
    чему и будет посвящена эта статья. Я постараюсь максимально просто
    и понятно ввести вас в курс дела, параллельно поясняя, что же такое
    списки и как их грамотно реализовать.
  </p>
</section>
<section class="even">
  <h2>Структуры</h2>
  <p>
    Так, стоять. Вот шла речь о классах, а тут внезапно структуры. Что за подстава?
    Всё просто. В С++ структуры и классы - это <i>одно и то же</i>. Единственное
    различие заключается в том, что у структуры по умолчанию все поля
    являются публичными, т.е. доступ к любому её аргументу можно получить
    извне, тогда как классы - это скрытные типы, которые шарятся
    по тёмным аллеям ночью в чёрных капюшонах и предоставляют только
    частичку информации о себе внешним источникам, оставив самое интересное
    себе.
  </p>
  <p>
    Классы мы, технически, ещё не проходили, поэтому придётся использовать
    структуры вне зависимости от того, насколько это подходит к поставленной
    задаче. Зато повезло нам в другом - люди, составлявшие условие к ОП 6, имели
    неосторожность оставить криво скопированный код с методами у функций, что
    даёт нам полное моральное право использовать все возможности классовой
    системы, а не корячиться с функциями, в которые передаются указатели.
    Кстати, указатели нам понадобятся - в С++ описание методов классов
    почти целиком состоит из работы с указателями.
  </p>
  <pre><code class="cpp">
struct Book {
    string author;
    string title;
    int pages;
};

Book example;
example.author = "Leo Tolstoy";
example.title = "War and Peace";

Book lectures = {"Bobrov", "Useful lectures", 0};
  </code></pre>
  <p>
    Вот таким нехитрым способом можно создать новую структуру. Ключевое слово
    struct позволило нам объявить новый тип данных Book, экземпляры которого
    имеют поля author и title типа string, и поле pages типа int. В таком
    формате гораздо удобнее хранить данные о книгах, потому что вместо
    трёх массивов данных нам достаточно создать один массив структур и извлекать
    данные из полей его составляющих.
  </p>
  <p>
    Как вы уже заметили, есть два способа заполнить структуру: можно сначала
    создать экземпляр класса и затем заполнить его поля по одиночке (пример
    с "Войной и миром") или предоставить данные в порядке их объявления в
    фигурных скобках при создании переменной (пример со сборником
    полезных лекций Боброва, состоящим из 0 страниц).
  </p>
  <h2>Разница между экземпляром класса и самим классом</h2>
  <p>
    Наверное, было бы неплохо объяснить, что такое экземпляр класса. Когда мы
    написали struct Book {...};, мы объявили новый тип, как, например, int или
    string. Это достаточно сделать один раз, после объявления типа мы можем
    создавать сколько угодно его экземпляров. Экземпляр - это конкретная
    переменная, принадлежащая этому типу. Проведём аналогию с биологией:
    Вид "Собака обыкновенная", или Canis Lupus Familiaris - это некий
    абстрактный концепт, придуманный человеком. Это что-то вроде шаблона, который описывает
    множество различных представителей этого вида. Мы не можем найти этот
    шаблон в реальном мире, он аморфен и существует только в нашем мозгу и в
    справочниках по зоологии. Зато его представителей, или экземпляров,
    полно - во дворе бегает Бобик, у соседей дома живёт Шарик, а в аэропорте
    вынюхивает наркотики Рекс. Бобик, Шарик и Рекс - экземпляры класса, про них
    нельзя почитать в учебнике, но зато к ним можно подойти и ткнуть в них пальцем
    (хотя лучше так не делать). Даже если кого-то
    из перечисленных псов мы не знаем, нам достоверно известно, что и Шарик, и Бобик,
    и тем более Рекс умеют гавкать, рычать и грызть кости, а также у каждого
    из них есть такие свойства, как порода, окрас и возраст. Известно это нам
    потому что все эти навыки (методы) и свойства (аттрибуты) есть в описании
    знакомого нам вида.
  </p>
  <h2>Попробуем на практике</h2>
  <p>
    Вернёмся к нашим баранам. Надеюсь, что процедура создания как самой структуры,
    так и её полей, предельно ясна. Вдруг мы решили, что биологический
    пример был настолько хорош (нет), что мы его даже повторим в С++. Посмотрим:
  </p>
  <pre><code class="cpp">
struct Dog {
    string breed;
    string color;
    int age = 0;
};

Dog bobik = {"Лабрабдор",
             "Чёрный с белыми пятнами",
             3};
  </code></pre>
  <p>
    С породой и окрасом всё понятно, а как быть с лаем и рычанием? Их нельзя
    просто записать в переменную, это же целые функции. Ну, на практике это мало
    повлияет на код:
  </p>
  <pre><code class="cpp">
  struct Dog {
    string breed;
    string color;
    int age = 0;

    void bark() {
        cout << "Гав!" << endl;
    }

    void growl() {
        cout << "Рррррр" << endl;
    }
};

Dog bobik = {"Боксёр",
             "Чёрный с белыми пятнами",
             3};
bobik.bark();
  </code></pre>
  <p>
    Если у вас стоит правильная IDE, то она точно вам сообщит о том,
    что методы bark и growl можно без потерь сделать статичными. Что это значит?
    Статический метод - это метод, который можно вызвать непосредственно у самого
    класса, без создания экземпляра: Dog.bark(); Статическими можно (и нужно)
    объявлять только те методы, которые не имеют привязки к конкретному
    экземпляру класса. Вот если бы у каждой собаки был свой звук лая,
    который назначается в соответствующее поле, мы бы уже не имели права
    назвать этот метод статичным.
  </p>
  <p>
    Кстати, как и обычные функции, методы можно объявить заранее, и затем реализовать
    их вне класса, но тогда придётся войти в его именное пространство:
  </p>
  <pre><code class="cpp">
struct Dog {
    void bark();
}

void Dog::bark() {
    cout << "ГАВ!" << endl;
}
  </code></pre>
  <h2>Напоследок о выводе</h2>
  <p>
    Вывод данных из структуры в консоль - занятие не из приятных. Согласитесь,
    вручную прописывать вывод каждого значащего поля структуры каждый раз,
    когда нам это нужно - сомнительное удовольствие. Вот здесь-то и вступает
    в силу одно из преимуществ потоков: можно настроить запись/чтение своего
    собственного в/из консоли (или любого другого потока). Для этого
    нужно совершить такую страшную штуку, как перегрузка операторов. Подробнее
    о ней мы поговорим позже, а пока просто научимся оформлять ввод/вывод:
  </p>
  <pre><code class="cpp">
struct Dog {
    string breed;
    string color;
    int age = 0;

    void bark() {
        cout << "Гав!" << endl;
    }
    void growl() {
        cout << "Ррррррр" << endl;
    }
    friend ostream& operator<< (ostream &out, Dog &self) {
        out << self.color << " " << self.breed;
        return out;  // Возвращаем поток, чтобы позволить комбинировать << выводы << вот << так
    }
};

Dog bobik = {"Boxer",
             "Black and white",
             3};
cout << bobik << endl;
  </code></pre>
  <p>
    Абсолютно аналогично оформляется и ввод данных в структуру из потока.
    friend - значит функция будет "дружественной" по отношению к переданным
    аргументам, т.е. они будут иметь полный доступ ко всем, даже скрытым
    полям структуры. Не спрашивайте меня, зачем это в структуре, у которой и так
    все поля открыты для общественного пользования, вариант функции без
    friend будет вызывать ошибку компиляции - все вопросы к авторам языка.
  </p>
</section>
<section class="odd">
  <h2>Списки как альтернатива массивам</h2>
  <p>
    Списки - это принципиально другой способ хранения набора данных. Массивы - это
    максимально простое решение, созданное, фактически, "в лоб" - объекты просто
    распологаются вплотную друг к другу. Они просто реализуются, предлагают
    шикарные возможности по прямому доступу к элементам по индексу и обеспечивают
    быстрый доступ к любому элементу, но их несколько проблематично расширять. Особенно,
    если новый элемент должен встать в середину массива.<br>
    Альтернативой являются списки. Элементами списка являются структуры, раскиданные
    по всей памяти по принципу "куда влезет". Возможность перебора элементов
    осуществляется за счёт хранения в каждом элементе указателя на следующий
    (в случае односвязного списка) или на следующий и предыдущий (в случае
    двусвязного списка) элементы. В итоге мы получаем гораздо более
    эффективную по времени (и усилиям программистов) процедуру добавления или
    удаления элемента из любой позиции. Но за это пришлось поплатиться: списки
    кушают больше памяти (указатели же надо хранить, а это далеко не самые
    маленькие вещи, скажу я вам), не позволяют получить прямой доступ к конкретному
    элементу (только через перебор) и демонстрируют сравнительно печальные результаты
    в области скорости доступа.
  </p>
  <p>
    Традиционно проведём аналогию для упрощения понимания. Массив - это вставшая
    по струнке рота в армии. Все солдаты стоят вплотную друг к другу и беспрекословно
    слушаются командира. Достаточно знать, где стоит первый солдат роты, положение
    остальных можно определить нехитрыми способами. Рота не станет спонтанно
    уменьшаться или увеличиваться в размере, если только это не было
    запланировано заранее.<br>
    Список же - это банда алконавтов на пьянке, которая постоянно то растёт и расширяется,
    то резко сужается. Размер пьянки никогда нельзя определить заранее, он ограничен
    лишь вместимостью хаты. Посетители пьянки разбрелись в поисках спиртного
    по всем углам дома, и собрать их в одну кучу будет как минимум проблематично.
    Годы чрезмерного злоупотребления алкоголем не обошли их стороной, и их
    память теперь в состоянии помнить всего несколько человек: кто их сюда привёл,
    кого они сюда привели, кто организовал пьянку вообще и кому надо наливать
    штрафную за то, что он припёрся последним (ради чистоты аналогии предположим,
    что это алкоголики-интроверты, которые не приглашают за собой больше одного
    человека).
  </p>
  <h2>План реализации</h2>
  <p>
    Написание структуры списка - достаточно серьёзное занятие, и нельзя просто
    сесть и начать писать код. Нужно заранее продумать, как она будет устроена,
    как будут взаимодействовать между собой элементы и какие у них будут методы.
    Начнём с разбора целей: мы хотим написать односвязный список, стек и очередь
    (производные от них, такие как двусвязный список, двусторонняя очередь
    и циклический список, не сложны в реализации - их можно будет сделать по образу
    и подобию этих структур). Стек и очередь можно оформить, как обёртки вокруг
    списка - список будет полем структуры, а сама структура будет предоставлять
    доступ к его элементам.
  </p>
  <p>
    Итак, в основе всего у нас лежит односвязный список. В итоговой версии
    односвязного списка нам нужно иметь методы:
  </p>
  <ol>
    <li>Получения первого и последнего элемента</li>
    <li>Добавления элемента в начало и в конец</li>
    <li>Добавления элемента в середину</li>
    <li>Удаления элемента из начала и конца</li>
    <li>Удаления элемента из середины</li>
  </ol>
  <p>
    Можно это реализовать одной структурой, но тогда возникнет следующая проблема:
    если мы добавим элемент в начало, то ссылка на первый элемент изменится.
    В таком случае придётся пройтись по каждому элементу списка и изменить его
    параметр root, что, мягко говоря, не является оптимальным выходом из ситуации.
    Вместо этого можно сделать две структуры: первая будет представлять один
    элемент из всего списка, а вторая будет заведовать всем списком. Тогда
    можно разделить методы между структурами. Пусть элементы списка реализуют
    удаление себя из списка и вставку элемента после себя, а обёртка (заведующая структура)
    будет заниматься вставкой элементов в начало и конец, поиском последнего элемента,
    определением размера списка и так далее.
  </p>
  <p>
    Исходя из придуманного плана, шаблоны структур должны выглядеть примерно так:
  </p>
  <pre><code class="cpp">
template &lt;typename type>
struct ForwardList;
template &lt;typename type>
struct ForwardListItem;

template &lt;typename type>
struct ForwardList {
    ForwardListItem&lt;type> *root = nullptr;
    ForwardListItem&lt;type> *end = nullptr;
    int size = 0;

    ForwardListItem&lt;type> *head();
    ForwardListItem&lt;type> *tail();
    type front();
    type back();

    void push_front(ForwardListItem&lt;type> *item);
    void push_front(type value);
    void push_back(ForwardListItem&lt;type> *item);
    void push_back(type value);

    type pop_front();
    type pop_back();

    int count();
    bool empty();
};

template &lt;typename type>
struct ForwardListItem {
    type value;
    ForwardListItem&lt;type> *next;
    ForwardList&lt;type> *root;

    void insert(ForwardListItem&lt;type> *item);
    void remove();
};
  </code></pre>
  <p>
    В самом начале файла мы объявляем, но не инициализируем структуры. Это
    делается для того, чтобы компилятор не выдавал ошибки при создании
    в структурах ссылок друг на друга (элементы списка помнят, в каком они
    списке, список хранит ссылку на первый и последний элементы). Некоторые
    методы у класса ForwardList продублированы, чтобы обеспечить интерфейс,
    удобный как программисту (работа со значениями, а не ListItem), так и нам
    самим (работа с ListItem). План готов, можно приступить к самой реализации.
  </p>
</section>
<section class="even">
  <h2>Конструкторы и деструкторы</h2>
  <p>
    Наивно было предполагать, что в первую очередь мы займёмся именно
    взаимодействием элементов. Для начала мы объявим конструкторы и деструкторы
    классов. Что это вообще? Конструктор - это метод класса, который вызывается
    при создании экземпляра. Людям, знакомым с C# или Java такая запись будет
    выглядеть гораздо более знакомой:
  </p>
  <pre><code class="cpp">
auto item = new ListItem(10);
  </code></pre>
</section>
{% endblock %}