{% extends "base.html" %}
{% block content %}
<section class="odd">
  <h1>Структуры и списки</h1>
  <p>
    Одной из ключевых особенностей C++ стала поддержка ООП, или объекто-ориентированного
    программирования. Концепт ООП построен на создании экземпляров (instances) различных
    классов, каждый из которых имеет набор членов (members) - полей-аттрибутов
    и методов. Существует ряд ключевых механизмов, таких как наследование и
    полиморфизм, но все эти темы пока изучать рано. Начать стоит с самых основ,
    чему и будет посвящена эта статья. Я постараюсь максимально просто
    и понятно ввести вас в курс дела, параллельно поясняя, что же такое
    списки и как их грамотно реализовать.
  </p>
</section>
<section class="even">
  <h2>Структуры</h2>
  <p>
    Так, стоять. Вот шла речь о классах, а тут внезапно структуры. Что за подстава?
    Всё просто. В С++ структуры и классы - это <i>одно и то же</i>.
    Существует три модификатора доступа - public, private и protected.
    public разраешает обращаться к полю откуда угодно, private запрещает
    доступ отовсюду кроме тела класса, protected даёт доступ только тем классам,
    которые являются потомками данного. Если модификатор явно не указан,
    в структуре подставляется public, а в классе - private. Иными словами, единственное
    различие заключается в том, что структура - весёлый экстраверт, всегда готовый
    поделиться своими мыслями и знаниями со всем миром, тогда как классы - это
    скрытные типы, интроверты, которые шарятся по тёмным аллеям ночью в чёрных
    капюшонах и предоставляют только частичку информации о себе внешним источникам,
    сохранив самое интересное в тайне. Смотрите:
  </p>
  <pre><code class="cpp">
class MyClass {
    int field1 = 0;
public:
    int field2 = 0;
private:
    int field3 = 0;
};

struct MyStruct {
    int field1 = 0;
public:
    int field2 = 0;
private:
    int field3 = 0;
};

MyClass a;
MyStruct b;
cout << a.field1 << endl;  // Незаконно, модификатор не уточнён, стандартный - private
cout << a.field2 << endl;  // Законно, указан явный модификатор public
cout << a.field3 << endl;  // Незаконно, указан явный модификатор private.

cout << b.field1 << endl;  // Законно, модификатор не уточнён, стандартный - public
cout << b.field2 << endl;  // Законно, указан явный модификатор public
cout << b.field3 << endl;  // Незаконно, указан явный модификатор private.
  </code></pre>
  <p>
    Классы мы, технически, ещё не проходили, поэтому придётся использовать
    структуры вне зависимости от того, насколько это подходит к поставленной
    задаче. Зато повезло нам в другом - люди, составлявшие условие к ОП 6, имели
    неосторожность оставить криво скопированный код с методами у функций, что
    даёт нам полное моральное право использовать все возможности классовой
    системы, а не корячиться с функциями, в которые передаются указатели.
    Кстати, указатели нам понадобятся - в С++ описание методов классов
    почти целиком состоит из работы с указателями.
  </p>
  <pre><code class="cpp">
struct Book {
    string author;
    string title;
    int pages;
};

Book example;
example.author = "Leo Tolstoy";
example.title = "War and Peace";

Book lectures = {"Bobrov", "Useful lectures", 0};
  </code></pre>
  <p>
    Вот таким нехитрым способом можно создать новую структуру. Ключевое слово
    struct позволило нам объявить новый тип данных Book, экземпляры которого
    имеют поля author и title типа string, и поле pages типа int. В таком
    формате гораздо удобнее хранить данные о книгах, потому что вместо
    трёх массивов данных нам достаточно создать один массив структур и извлекать
    данные из полей его составляющих.
  </p>
  <p>
    Как вы уже заметили, есть два способа заполнить структуру: можно сначала
    создать экземпляр класса и затем заполнить его поля по одиночке (пример
    с "Войной и миром") или предоставить данные в порядке их объявления в
    фигурных скобках при создании переменной (пример со сборником
    полезных лекций Боброва, состоящим из 0 страниц).
  </p>
  <h2>Разница между экземпляром класса и самим классом</h2>
  <p>
    Наверное, было бы неплохо объяснить, что такое экземпляр класса. Когда мы
    написали struct Book {...};, мы объявили новый тип, как, например, int или
    string. Это достаточно сделать один раз, после объявления типа мы можем
    создавать сколько угодно его экземпляров. Экземпляр - это конкретная
    переменная, принадлежащая этому типу. Проведём аналогию с биологией:
    Вид "Собака обыкновенная", или Canis Lupus Familiaris - это некий
    абстрактный концепт, придуманный человеком. Это что-то вроде шаблона, который описывает
    множество различных представителей этого вида. Мы не можем найти этот
    шаблон в реальном мире, он аморфен и существует только в нашем мозгу и в
    справочниках по зоологии. Зато его представителей, или экземпляров,
    полно - во дворе бегает Бобик, у соседей дома живёт Шарик, а в аэропорте
    вынюхивает наркотики Рекс. Бобик, Шарик и Рекс - экземпляры класса, про них
    нельзя почитать в учебнике, но зато к ним можно подойти и ткнуть в них пальцем
    (хотя лучше так не делать). Даже если кого-то
    из перечисленных псов мы не знаем, нам достоверно известно, что и Шарик, и Бобик,
    и тем более Рекс умеют гавкать, рычать и грызть кости, а также у каждого
    из них есть такие свойства, как порода, окрас и возраст. Известно это нам
    потому что все эти навыки (методы) и свойства (аттрибуты) есть в описании
    знакомого нам вида.
  </p>
  <h2>Попробуем на практике</h2>
  <p>
    Вернёмся к нашим баранам. Надеюсь, что процедура создания как самой структуры,
    так и её полей, предельно ясна. Вдруг мы решили, что биологический
    пример был настолько хорош (нет), что мы его даже повторим в С++. Посмотрим:
  </p>
  <pre><code class="cpp">
struct Dog {
    string breed;
    string color;
    int age = 0;
};

Dog bobik = {"Лабрабдор",
             "Чёрный с белыми пятнами",
             3};
  </code></pre>
  <p>
    С породой и окрасом всё понятно, а как быть с лаем и рычанием? Их нельзя
    просто записать в переменную, это же целые функции. Ну, на практике это мало
    повлияет на код:
  </p>
  <pre><code class="cpp">
struct Dog {
    string breed;
    string color;
    int age = 0;

    void bark() {
        cout << "Гав!" << endl;
    }

    void growl() {
        cout << "Рррррр" << endl;
    }
};

Dog bobik = {"Боксёр",
             "Чёрный с белыми пятнами",
             3};
bobik.bark();
  </code></pre>
  <p>
    Если у вас стоит правильная IDE, то она точно вам сообщит о том,
    что методы bark и growl можно без потерь сделать статичными. Что это значит?
    Статический метод - это метод, который можно вызвать непосредственно у самого
    класса, без создания экземпляра: Dog::bark(); Статическими можно (и нужно)
    объявлять только те методы, которые не имеют привязки к конкретному
    экземпляру класса. Вот если бы у каждой собаки был свой звук лая,
    который назначается в соответствующее поле, мы бы уже не имели права
    назвать этот метод статичным.
  </p>
  <p>
    Кстати, как и обычные функции, методы можно объявить заранее, и затем реализовать
    их вне класса, но тогда придётся войти в его именное пространство:
  </p>
  <pre><code class="cpp">
struct Dog {
    void bark();
}

void Dog::bark() {
    cout << "ГАВ!" << endl;
}
  </code></pre>
  <h2>Напоследок о выводе</h2>
  <p>
    Вывод данных из структуры в консоль - занятие не из приятных. Согласитесь,
    вручную прописывать вывод каждого значащего поля структуры каждый раз,
    когда нам это нужно - сомнительное удовольствие. Вот здесь-то и вступает
    в силу одно из преимуществ потоков: можно настроить вывод своего
    собственного класса в консоль (или любого другого потока), точно также,
    как и ввод данных в класс из потока. Для этого нужно совершить такую страшную штуку,
    как перегрузка операторов. Подробнее о ней мы поговорим позже, а пока просто
    научимся оформлять ввод/вывод:
  </p>
  <pre><code class="cpp">
struct Dog {
    string breed;
    string color;
    int age = 0;

    void bark() {
        cout << "Гав!" << endl;
    }
    void growl() {
        cout << "Ррррррр" << endl;
    }
    friend ostream& operator<< (ostream &out, Dog &self) {
        out << self.color << " " << self.breed;
        return out;  // Возвращаем поток, чтобы позволить комбинировать << выводы << вот << так
    }
};

Dog bobik = {"Boxer",
             "Black and white",
             3};
cout << bobik << endl;
  </code></pre>
  <p>
    Абсолютно аналогично оформляется и ввод данных в структуру из потока.
    friend - значит функция будет "дружественной" по отношению к переданным
    аргументам, т.е. они будут иметь полный доступ ко всем, даже скрытым
    полям структуры. Не спрашивайте меня, зачем это в структуре, у которой и так
    все поля открыты для общественного пользования, вариант функции без
    friend будет вызывать ошибку компиляции - все вопросы к авторам языка.
  </p>
</section>
<section class="odd">
  <h2>Списки как альтернатива массивам</h2>
  <p>
    Списки - это принципиально новый способ хранения набора данных. Массивы - это
    максимально простое решение, созданное, фактически, "в лоб" - объекты просто
    распологаются вплотную друг к другу. Они просто реализуются, предлагают
    шикарные возможности по прямому доступу к элементам по индексу и обеспечивают
    быстрый доступ к любому элементу, но их несколько проблематично расширять. Особенно,
    если новый элемент должен встать в середину массива.<br>
    Альтернативой являются списки. Элементами списка являются структуры, раскиданные
    по всей памяти по принципу "куда влезет". Возможность перебора элементов
    осуществляется за счёт хранения в каждом элементе указателя на следующий
    (в случае односвязного списка) или на следующий и предыдущий (в случае
    двусвязного списка) элементы. В итоге мы получаем гораздо более
    эффективную по времени (и усилиям программистов) процедуру добавления или
    удаления элемента из любой позиции. Но за это пришлось поплатиться: списки
    кушают больше памяти (указатели же надо хранить, а это далеко не самые
    маленькие вещи, скажу я вам), не позволяют получить прямой доступ к конкретному
    элементу (только через перебор) и демонстрируют сравнительно печальные результаты
    в области скорости доступа.
  </p>
  <p>
    Традиционно проведём аналогию для упрощения понимания. Массив - это вставшая
    по струнке рота в армии. Все солдаты стоят вплотную друг к другу и беспрекословно
    слушаются командира. Достаточно знать, где стоит первый солдат роты, положение
    остальных можно определить нехитрыми способами. Рота не станет спонтанно
    уменьшаться или увеличиваться в размере, если только это не было
    запланировано заранее.<br>
    Список же - это банда алконавтов на пьянке, которая постоянно то растёт и расширяется,
    то резко сужается. Размер пьянки никогда нельзя определить заранее, он ограничен
    лишь вместимостью хаты. Посетители пьянки разбрелись в поисках спиртного
    по всем углам дома, и собрать их в одну кучу будет как минимум проблематично.
    Годы чрезмерного злоупотребления алкоголем не обошли их стороной, и их
    память теперь в состоянии помнить всего несколько человек: кто их сюда привёл,
    кого они сюда привели, кто организовал пьянку вообще и кому надо наливать
    штрафную за то, что он припёрся последним (ради чистоты аналогии предположим,
    что это алкоголики-интроверты, которые не приглашают за собой больше одного
    человека).
  </p>
  <h2>План реализации</h2>
  <p>
    Написание структуры списка - достаточно серьёзное занятие, и нельзя просто
    сесть и начать писать код. Нужно заранее продумать, как она будет устроена,
    как будут взаимодействовать между собой элементы и какие у них будут методы.
    Начнём с разбора целей: мы хотим написать односвязный список, стек и очередь
    (производные от них, такие как двусвязный список, двусторонняя очередь
    и циклический список, не сложны в реализации - их можно будет сделать по образу
    и подобию этих структур). Стек и очередь можно оформить, как обёртки вокруг
    списка - список будет полем структуры, а сама структура будет предоставлять
    доступ к его элементам.
  </p>
  <p>
    Итак, в основе всего у нас лежит односвязный список. В итоговой версии
    односвязного списка нам нужно иметь методы:
  </p>
  <ol>
    <li>Получения первого и последнего элемента</li>
    <li>Добавления элемента в начало и в конец</li>
    <li>Добавления элемента в середину</li>
    <li>Удаления элемента из начала и конца</li>
    <li>Удаления элемента из середины</li>
  </ol>
  <p>
    Можно это реализовать одной структурой, но тогда возникнет следующая проблема:
    если мы добавим элемент в начало, то ссылка на первый элемент изменится.
    В таком случае придётся пройтись по каждому элементу списка и изменить его
    параметр root, что, мягко говоря, не является оптимальным выходом из ситуации.
    Вместо этого можно сделать две структуры: первая будет представлять один
    элемент из всего списка, а вторая будет заведовать всем списком. Тогда
    можно разделить методы между структурами. Пусть элементы списка реализуют
    удаление себя из списка и вставку элемента после себя, а обёртка (заведующая структура)
    будет заниматься вставкой элементов в начало и конец, поиском последнего элемента,
    определением размера списка и так далее.
  </p>
  <p>
    Исходя из придуманного плана, шаблоны структур должны выглядеть примерно так:
  </p>
  <pre><code class="cpp">
template &lt;typename type>
struct ForwardList;
template &lt;typename type>
struct ForwardListItem;

template &lt;typename type>
struct ForwardList {
    ForwardListItem&lt;type> *root = nullptr;
    int size = 0;

    ForwardListItem&lt;type> *head();
    ForwardListItem&lt;type> *tail();
    type front();
    type back();

    void push_front(ForwardListItem&lt;type> *item);
    void push_front(type value);
    void push_back(ForwardListItem&lt;type> *item);
    void push_back(type value);

    type pop_front();
    type pop_back();

    void recount();
    bool empty();
};

template &lt;typename type>
struct ForwardListItem {
    type value;
    ForwardListItem&lt;type> *next = nullptr;
    ForwardList&lt;type> *root = nullptr;

    ForwardListItem&lt;type> *head();
    ForwardListItem&lt;type> *tail();
    void insert(ForwardListItem&lt;type> *item);
    void remove();
};
  </code></pre>
  <p>
    В самом начале файла мы объявляем, но не инициализируем структуры. Это
    делается для того, чтобы компилятор не выдавал ошибки при создании
    в структурах ссылок друг на друга (элементы списка помнят, в каком они
    списке, список хранит ссылку на первый и последний элементы). Некоторые
    методы у класса ForwardList продублированы, чтобы обеспечить интерфейс,
    удобный как программисту (работа со значениями, а не ListItem), так и нам
    самим (работа с ListItem). План готов, можно приступить к самой реализации.
  </p>
</section>
<section class="even">
  <h2>Конструкторы и деструкторы</h2>
  <p>
    Наивно было предполагать, что в первую очередь мы займёмся именно
    взаимодействием элементов. Для начала мы объявим конструкторы и деструкторы
    классов. Что это вообще? Конструктор - это метод класса, который вызывается
    при создании экземпляра. Людям, знакомым с C# или Java такая запись будет
    выглядеть гораздо более знакомой:
  </p>
  <pre><code class="cpp">
auto item = new ListItem(10);
  </code></pre>
  <p>
    Если попробовать вызвать класс, как функцию (что мы и видим на примере), то
    программа попытается вызвать конструктор класса - функцию, которая создаёт
    новый экземпляр класса и возвращает его. По умолчанию такой функции нет,
    и компилятор любезно вам это проорёт, но её можно объявить, как метод класса:
  </p>
  <pre><code class="cpp">
struct CustomClass {
    int var;

    CustomClass(int value) {
        this->var = value;
    }
};
  </code></pre>
  <p>
    В теле класса мы просто объявляем метод, название которого совпадает с названием класса.
    Возвращаемый тип мы <b>не указываем</b>. Аналогично создаются и деструкторы, то есть методы,
    которые вызываются при попытке удалить экземпляр класса через delete:
  </p>
  <pre><code class="cpp">
struct Array {
    int *nums = new int[10];

    ~Array() {
        delete this->nums;
    }
};
  </code></pre>
  <p>
    Возникает другой вопрос: кто такой this и почему от него идёт стрелочка? this - это ключевое слово,
    которое хранит в себе указатель на экземпляр класса, у которого вызывается метод. Иными словами,
    почти у каждого метода класса есть скрытый аргумент this, который хранит указатель на конкретный
    объект класса, с которым этот метод должен взаимодействовать. Это даёт 100% гарантию, что значение
    мы меняем только у одного конкретного объекта (подробнее о том, зачем это вообще надо, мы поговорим
    сильно позже).<br>
    Что же касается стрелки - она играет ту же роль, что и точка, но у указателей. Следующий код должен
    достаточно наглядно это продемонстрировать:
  </p>
  <pre><code class="cpp">
struct Number {
    int val;
};

Number a = {10};
Number *ptr = &amp;a;
cout << a.val << " " << ptr->val << endl;
  </code></pre>
  <p>
    Так как классы, в основном, работают с указателями, пользоваться такой стрелочкой
    гораздо удобнее, чем вручную разименовывать указатели и пытаться достать их содержимое.
    Согласитесь, this->next->next удобнее монстроподобных конструкций вида *(*this.next).next (которые
    ещё и не будут компилироваться).
  </p>
  <p>
    Вернёмся к спискам, пока не поздно. В теории, нам достаточно реализовать только деструктор
    для списка и конструктор для элемента списка. Деструктор списка должен удалить
    каждый элемент списка:
  </p>
  <pre><code class="cpp">
~ForwardList() {
    while (!this->empty()) {
        this->pop_front();
    }
}
  </code></pre>
  <p>
    Конструктор элемента списка будет также примитивен, но в итоге крайне удобен:
  </p>
  <pre><code class="cpp">
explicit ForwardListItem(type value) {
    this->value = value;
}
  </code></pre>
  <p>
    Так, а что это за explicit? Explicit - ключевое слово, введённое в С++
    чтобы отличать конструкторы с одним обязательным аргументом от С-подобного
    приведения типов. Начиная со стандарта С++11 у слова появилось больше
    применений, которые, если верить Хабру, "должны навести порядок в зоопарке
    способов инициализации объектов, доставшемся C++ в наследство от языка C".
    Иными словами, <i>так просто лучше, подробности когда-нибудь потом изучим</i>.
  </p>
  <p>
    Ну, с мелочами и основами разобрались, теперь можно приступить к работе и над геморройными элементами.
  </p>
</section>
<section class="odd">
  <h2>Вставка и удаление в список</h2>
  <p>
    Чтобы вставить элемент в середину или конец списка, нужно изменить всего три указателя. Предположим,
    что у нас есть элементы A и С, уже находящиеся в списке, и элемент B, который мы хотим вставить между ними.
    В данный момент A->next == C. Чтобы сохранить связь с элементом С, его адрес мы запишем в элемент B:
    B->next = A->next. Чтобы B имел конкретное положение в списке, а не валялся в астральных уголках памяти
    показывая пальцем на С, нужно изменить параметр next у А: A->next = B. Ну и было бы неплохо рассказать B о зачинщике
    этого списка: B->root = A->root. Реализуем это в качестве метода insert у элемента списка, чтобы A был равен
    this, а B - переданному аргументу.
  </p>
  <pre><code class="cpp">
void insert(ForwardListItem&lt;type> *item) {
    // Привязываем элемент к списку
    item->root = this->root;
    // Вставляем его между этим и следующим
    item->next = this->next;
    this->next = item;
    // Увеличиваем длину в менеджере
    this->root->size++;
}
  </code></pre>
  <p>
    Просто и элегантно. Если элемент A будет последним, то его параметр next будет указывать на nullptr,
    что мы успешно скопируем в B без каких-либо ошибок компиляции или косяков в рантайме.
  </p>
  <p>
    Пришла очередь удаления элемента из списка. Было бы странно, если бы при вызове A->remove() удалялся не А,
    а А->next. По сей причине придётся пожертвовать скоростью работы и идти от головы до элемента предшествующего
    А (проблемы не будет в двусвязном списке, что ускорит работоспособность, но будет кушать ещё больше памяти.
    Если мы хотим именно список, то лучше пожертвовать памятью ради скорости, но в случае стека или очереди
    двусвязный список не даст никакого прироста скорости, только зохавает ещё больше ценной (нет) оперативы).
    Алгоритм всё также прост. Есть элементы A, B и C, идущие подряд. При вызове B->remove() A станет указывать
    на C и, собственно, на этом всё. Отдельно стоит проверить, является ли элемент списка первым - в таком случае
    придётся залезть в сам список и изменить указатель root на next от элемента.
  </p>
  <pre><code class="cpp">
void remove() {
    auto curr = this->head();
    if (curr == this) {
        // Если удаляем первый элемент, то нужно
        // перенаправить корень менеджера на следующий,
        // будь то реальный элемент или nullptr
        this->root->root = this->next;
    } else {
        // Ищем предыдущий элемент от головы
        while (curr->next != this) {
            curr = curr->next;
        }
        // Избавляемся от ссылки на себя
        curr->next = this->next;
    }
    // Уменьшаем длину в менеджере
    this->root->size--;
}
  </code></pre>
  <p>
    Теперь можно реализовать и крайне тяжёлые в исполнении методы head и
    tail:
  </p>
  <pre><code class="cpp">
ForwardListItem&lt;type> *head() {
    return this->root->head();
}

ForwardListItem&lt;type> *tail() {
    auto curr = this;
    while (curr->next != nullptr) {
        curr = curr->next;
    }
    return curr;
}
  </code></pre>
  <p>
    Структура ForwardListItem готова, можно приступать к ForwardList.
    Начнём с всё тех же head и tail:
  </p>
  <pre><code class="cpp">
ForwardListItem&lt;type> *head() {
        return this->root;
    }

ForwardListItem&lt;type> *tail() {
    // Если в списке нет элементов, вернём nullptr
    if (this->root == nullptr) {
        return nullptr;
    }
    return this->root->tail();
}
  </code></pre>
  <p>
    Удобства ради, добавим также методы front и back, которые
    вернут значения из head и tail:
  </p>
  <pre><code class="cpp">
type front() {
    return this->head()->value;
}

type back() {
    return this->tail()->value;
}
  </code></pre>
  <p>
    Как вы уже заметили в tail, нам почти не придётся придумывать код для
    самого списка, мы будем совершать примитивные (по большей части) операции
    для получения нужного элемента и затем совершать манипуляции с его методами.
    Теперь реализуем методы empty и recount (просто потому что они простые).
  </p>
  <pre><code class="cpp">
void recount() {
    this->size = 0;
    for (auto curr = this->head(); curr != nullptr; curr = curr->next) {
        this->size++;
    }
}

bool empty() {
    return !this->size;
}
  </code></pre>
  <p>
    Метод recount, на самом деле, нам особо сильно и не нужен, но лишним
    не будет - например, он позволяет пересчитать размер списка при создании
    его не на пустом месте, а на основании какого-то элемента, за которым
    уже может тянуться хвост (написание такого конструктора доверю читателю).
  </p>
  <p>
    Теперь займёмся вставкой элементов в начало и конец списка. Вставка в конец
    - задача предельно простая, достаточно вызвать у tail() метод insert (если
    список не пуст, конечно же):
  </p>
  <pre><code class="cpp">
void push_back(ForwardListItem&lt;type> *item) {
    if (!this->empty()) {
        // Если список не пуст, можно просто insert-нуть после хвоста
        this->tail()->insert(item);
    } else {
        // Если же список пуст, засунем в начало, потому что
        // там эта ветка уже есть, нет смысла заново это писать.
        this->push_front(item);
    }
}

void push_back(type value) {
    // Клон для удобства
    auto item = new ForwardListItem(value);
    this->push_back(item);
}
  </code></pre>
  <p>
    По похожей схеме осуществим вставку в начало:
  </p>
  <pre><code class="cpp">
void push_front(ForwardListItem&lt;type> *item) {
    // Привязываем элемент к списку и назначаем бывший головной элемент в слот next
    item->root = this;
    item->next = this->root;
    // Меняем головной элемент в менеджере
    this->root = item;
    // Меняем размер
    this->size++;
}

void push_front(type value) {
    // Клон для удобства, создаёт элемент и вызывает существующий метод
    auto item = new ForwardListItem(value);
    this->push_front(item);
}
  </code></pre>
</section>
<section class="even">
  <h2>Удаление элементов</h2>
  <p>
    Удалять элементы c конца сложнее, чем добавлять в конец, преимущественно
    из-за необходимости оптимизировать этот процесс.
  </p>
  <pre><code class="cpp">
type pop_back() {
    type val;
    if (this->size == 1) {
        // Если в списке всего один элемент, не ищем предыдущий,
        // сразу назначаем root = nullptr
        val = this->root->value;
        delete this->root;
        this->root = nullptr;
    } else {
        // Иначе ищем предпоследний элемент и через него
        // извлекаем и удаляем последний
        auto curr = this->head();
        while (curr->next->next != nullptr) {
            curr = curr->next;
        }
        val = curr->next->value;
        delete curr->next;
        curr->next = nullptr;
        // Технически, можно не заморачиваться и просто вызвать tail() и его remove(),
        // но это негативно скажется на скорости работы. В двусвязном такой проблемы
        // нет, там так и делайте.
    }
    // Уменьшаем размер, возвращаем значение
    this->size--;
    return val;
}
  </code></pre>
  <p>
    Ну, покодили сложные штуки и хватит, теперь будем добавлять в начало:
  </p>
  <pre><code class="cpp">
type pop_front() {
    // Временно сохраняем голову, удаляем её из списка,
    // затем удаляем окончательно и возвращаем сохранённое значение
    auto item = this->root;
    item->remove();
    type val = item->value;
    delete item;
    return val;
}
  </code></pre>
  <p>
    Ну и в заключение работы над списком запилим ему бонусный метод,
    итератор, принимающий функцию-callback. Что это вообще?
    Итератор - это такая штукенция, которая позволяет по очереди
    поработать с каждым элементом какого-либо контейнера. Callback - это
    функция, которая передаётся в функцию в качестве аргумента и уже
    затем вызывается внутри этой функции. В нашем случае, итератор - это
    функция, которая получит callback функцию и применит её по очереди к каждому
    элементу списка. Проходиться по списку мы уже умеем, не раз это делали,
    теперь просто добавим к этому callback:
  </p>
  <pre><code class="cpp">
// Обратите внимание на формат, в котором мы записали аргумент -
// сначала возвращаемый тип, затем в скобках звёздочка и название функции,
// затем принимаемые аргументы.
void iter(void (*operation)(ForwardListItem&lt;type>*)) {
    for (auto curr = this->head(); curr != nullptr; curr = curr->next) {
        operation(curr);
    }
}
  </code></pre>
  <p>
    В примере в конце статьи можно посмотреть, как это всё работает. Там
    будет создана функция print, которую мы затем передадим в качестве аргумента
    для вывода на экран всего списка.
  </p>
  <p>
    На этом заканчивается односвязный список. Теперь напишем обёртки,
    реализующие стек и очередь.
  </p>
</section>
<section class="odd">
  <h2>Стек</h2>
  <p>
    Стек реализуется без лишних извращений: храним внутри указатель
    на односвязный список, создаём методы, которые вызовут соответствующие методы
    у хранимого списка и сидим довольные. Нам нужна проверка на пустоту,
    удаление с начала, добавление в начало (не важно, в какой конец мы будем
    добавлять элементы, главное, чтобы они добавлялись и удалялись с одной и той
    же стороны, а удалять и добавлять головные элементы гораздо проще и быстрее,
    чем хвостовые).
  </p>
  <pre><code class="cpp">
template &lt;typename type>
struct Stack {
private:
    // Объявляем список как приватный член класса,
    // иначе вся эта мишура со стеком не будет иметь никакого
    // смысла
    ForwardList&lt;type> *list = nullptr;

public:
    Stack() {
        this->list = new ForwardList&lt;type>;
    }

    void push(type value) {
        this->list->push_front(value);
    }

    type pop() {
        return this->list->pop_front();
    }

    type peek() {
        return this->list->front();
    }

    bool empty() {
        return this->list->empty();
    }

    ~Stack() {
        delete this->list;
    }
};
  </code></pre>
  <p>
    Искренне надеюсь, что пояснять что-то здесь не нужно.
  </p>
  <h2>Очередь</h2>
  <p>
    С очередью немного сложнее - добавляем мы всё в один конец, а читаем
    с другого. Здесь можно ради оптимизации завести ещё один указатель,
    который будет тыкать на последний элемент. Вставлять новые элементы будем
    в конец, удалять из головы (удаление из головы происходит гораздо быстрее,
    чем из любого другого места, тем более из конца; вставка в конец занимает
    столько же, сколько и в любое другое место).
  </p>
  <pre><code class="cpp">
template &lt;typename type>
struct Queue {
private:
    ForwardList&lt;type> *list = nullptr;
    // Сохраняем указатель на последний элемент, чтобы
    // ускорить добавление элементов
    ForwardListItem&lt;type> *end = nullptr;
public:
    Queue() {
        this->list = new ForwardList&lt;type>;
    }

    void push(type value) {
        auto item = new ForwardListItem(value);
        if (this->empty()) {
            this->list->push_front(item);
        } else {
            this->end->insert(item);
        }
        this->end = item;
    }

    type pop() {
        return this->list->pop_front();
    }

    type peek() {
        return this->list->front();
    }

    bool empty() {
        return this->list->empty();
    }
};
  </code></pre>
  <p>
    Как-то так. В конце-концов должен получиться такой код:
  </p>
  <pre><code class="cpp">
template &lt;typename type>
struct ForwardList;
template &lt;typename type>
struct ForwardListItem;
template &lt;typename type>
struct Stack;
template &lt;typename type>
struct Queue;

template &lt;typename type>
struct ForwardList {
    ForwardListItem&lt;type> *root = nullptr;
    int size = 0;

    ForwardListItem&lt;type> *head() {
        return this->root;
    }

    ForwardListItem&lt;type> *tail() {
        // Если в списке нет элементов, вернём nullptr
        if (this->root == nullptr) {
            return nullptr;
        }
        return this->root->tail();
    }

    // front и back - аналоги head и tail, но дающие значение.
    type front() {
        return this->head()->value;
    }

    type back() {
        return this->tail()->value;
    }

    void push_front(ForwardListItem&lt;type> *item) {
        // Привязываем элемент к списку и назначаем бывший головной элемент в слот next
        item->root = this;
        item->next = this->root;
        // Меняем головной элемент в менеджере
        this->root = item;
        // Меняем размер
        this->size++;
    }

    void push_front(type value) {
        // Клон для удобства, создаёт элемент и вызывает существующий метод
        auto item = new ForwardListItem(value);
        this->push_front(item);
    }

    void push_back(ForwardListItem&lt;type> *item) {
        if (!this->empty()) {
            // Если список не пуст, можно просто insert-нуть после хвоста
            this->tail()->insert(item);
        } else {
            // Если же список пуст, засунем в начало, потому что
            // там эта ветка уже есть, нет смысла заново это писать.
            this->push_front(item);
        }
    }

    void push_back(type value) {
        // Клон для удобства
        auto item = new ForwardListItem(value);
        this->push_back(item);
    }

    type pop_back() {
        type val;
        if (this->size == 1) {
            // Если в списке всего один элемент, не ищем предыдущий,
            // сразу назначаем root = nullptr
            val = this->root->value;
            delete this->root;
            this->root = nullptr;
        } else {
            // Иначе ищем предпоследний элемент и через него
            // извлекаем и удаляем последний
            auto curr = this->head();
            while (curr->next->next != nullptr) {
                curr = curr->next;
            }
            val = curr->next->value;
            delete curr->next;
            curr->next = nullptr;
            // Технически, можно не заморачиваться и просто вызвать tail() и его remove(),
            // но это негативно скажется на скорости работы. В двусвязном такой проблемы
            // нет, там так и делайте.
        }
        // Уменьшаем размер, возвращаем значение
        this->size--;
        return val;
    }

    type pop_front() {
        // Временно сохраняем голову, удаляем её из списка,
        // затем удаляем окончательно и возвращаем сохранённое значение
        auto item = this->root;
        item->remove();
        type val = item->value;
        delete item;
        return val;
    }

    void iter(void (*operation)(ForwardListItem&lt;type>*)) {
        for (auto curr = this->head(); curr != nullptr; curr = curr->next) {
            operation(curr);
        }
    }

    void recount() {
        this->size = 0;
        for (auto curr = this->head(); curr != nullptr; curr = curr->next) {
            this->size++;
        }
    }

    bool empty() {
        return !this->size;
    }

    ~ForwardList() {
        while (!this->empty()) {
            this->pop_front();
        }
    }
};

template &lt;typename type>
struct ForwardListItem {
    type value;
    ForwardListItem&lt;type> *next = nullptr;
    ForwardList&lt;type> *root = nullptr;

    explicit ForwardListItem(type value) {
        this->value = value;
    }

    ForwardListItem&lt;type> *head() {
        return this->root->head();
    }

    ForwardListItem&lt;type> *tail() {
        auto curr = this;
        while (curr->next != nullptr) {
            curr = curr->next;
        }
        return curr;
    }

    void insert(ForwardListItem&lt;type> *item) {
        // Привязываем элемент к списку
        item->root = this->root;
        // Вставляем его между этим и следующим
        item->next = this->next;
        this->next = item;
        // Увеличиваем длину в менеджере
        this->root->size++;
    }

    void remove() {
        auto curr = this->head();
        if (curr == this) {
            // Если удаляем первый элемент, то нужно
            // перенаправить корень менеджера на следующий,
            // будь то реальный элемент или nullptr
            this->root->root = this->next;
        } else {
            // Ищем предыдущий элемент от головы
            while (curr->next != this) {
                curr = curr->next;
            }
            // Избавляемся от ссылки на себя
            curr->next = this->next;
        }
        // Уменьшаем длину в менеджере
        this->root->size--;
    }
};

template &lt;typename type>
struct Stack {
private:
    ForwardList&lt;type> *list = nullptr;

public:
    Stack() {
        this->list = new ForwardList&lt;type>;
    }

    void push(type value) {
        this->list->push_front(value);
    }

    type pop() {
        return this->list->pop_front();
    }

    type peek() {
        return this->list->front();
    }

    bool empty() {
        return this->list->empty();
    }

    ~Stack() {
        delete this->list;
    }
};

template &lt;typename type>
struct Queue {
private:
    ForwardList&lt;type> *list = nullptr;
    // Сохраняем указатель на последний элемент, чтобы
    // ускорить добавление элементов
    ForwardListItem&lt;type> *end = nullptr;
public:
    Queue() {
        this->list = new ForwardList&lt;type>;
    }

    void push(type value) {
        auto item = new ForwardListItem(value);
        if (this->empty()) {
            this->list->push_front(item);
        } else {
            this->end->insert(item);
        }
        this->end = item;
    }

    type pop() {
        return this->list->pop_front();
    }

    type peek() {
        return this->list->front();
    }

    bool empty() {
        return this->list->empty();
    }

    ~Queue() {
        delete this->list;
    }
};
  </code></pre>
  <p>
    Представим, что всё это лежит в файле mylist.hpp и напишем код, который
    продемонстрирует все возможности сего монстра.
  </p>
  <pre><code class="cpp">
  #include &lt;iostream>
#include "mylist.hpp"

using namespace std;

template &lt;typename type>
void print(ForwardListItem&lt;type> *item) {
    cout &lt;&lt; item->value &lt;&lt; endl;
}

struct Book {
    string title;
    string author;

    Book() = default;

    Book(string &title, string &author) {
        this->title = title;
        this->author = author;
    }

    friend ostream& operator&lt;&lt; (ostream &out, const Book& self) {
        out &lt;&lt; '"' &lt;&lt; self.title &lt;&lt; "\", a book by " &lt;&lt; self.author;
        return out;  // Возвращаем поток, чтобы позволить комбинировать &lt;&lt; выводы &lt;&lt; вот &lt;&lt; так
    }
};

int main() {
    // Создание списка на основе встроенного типа
    cout &lt;&lt; "Showing list" &lt;&lt; endl;
    ForwardList&lt;int> *list = new ForwardList&lt;int>;
    for (int i=0; i &lt; 10; i++) {
        int n = rand() % 200 - 100;
        cout &lt;&lt; "Adding " &lt;&lt; n;
        if (i % 2) {
            // Добавление в начало
            list->push_front(n);
            cout &lt;&lt; " to front" &lt;&lt; endl;
        } else {
            // Добавление в конец
            list->push_back(n);
            cout &lt;&lt; " to back" &lt;&lt; endl;
        }
    }
    cout &lt;&lt; "Peeked at " &lt;&lt; list->front() &lt;&lt; " in front and " &lt;&lt; list->back() &lt;&lt; " in the back" &lt;&lt; endl;
    // Итерация по callback функции
    cout &lt;&lt; "Using callback to print list" &lt;&lt; endl;
    cout &lt;&lt; "----------------------------" &lt;&lt; endl;
    list->iter(print);
    cout &lt;&lt; "----------------------------" &lt;&lt; endl;
    for (int i=0; i &lt; 5; i++) {
        // Удаление с начала
        cout &lt;&lt; "Popped " &lt;&lt; list->pop_front() &lt;&lt; " from front" &lt;&lt; endl;
        // Удаление с конца
        cout &lt;&lt; "Popped " &lt;&lt; list->pop_back() &lt;&lt; " from back" &lt;&lt; endl;
    }
    delete list;

    string titles[] = {"War and Peace", "Art of War", "Everything is f*cked: A book about Hope",
                       "The Subtle Art of not Giving a F*ck", "Food Fight Club"};
    string authors[] = {"Leo Tolstoy", "Sun Tzu", "Mark Manson", "Mark Manson", "Jamie Oliver"};

    cout &lt;&lt; "Showing stack" &lt;&lt; endl;
    // Стек из структур
    Stack&lt;Book> *stack = new Stack&lt;Book>();
    for (int i=0; i &lt; 5; i++) {
        // Добавление в стек
        stack->push(Book(titles[i], authors[i]));
        // Просмотр элемента на верхушке стека
        cout &lt;&lt; "Added " &lt;&lt; stack->peek() &lt;&lt; " to stack" &lt;&lt; endl;
    }
    // Проверка на пустоту
    while (!stack->empty()) {
        // Извлечение из стека
        cout &lt;&lt; "Popped " &lt;&lt; stack->pop() &lt;&lt; " from stack" &lt;&lt; endl;
    }
    delete stack;

    cout &lt;&lt; "Showing queue" &lt;&lt; endl;
    // Создание очереди
    Queue&lt;string> *queue = new Queue&lt;string>();
    for (int i=0; i &lt; 5; i++) {
        string a;
        cout &lt;&lt; "Enter name to add to queue:" &lt;&lt; endl;
        cin >> a;
        // Добавление в очередь
        queue->push(a);
    }
    // Пока очередь не опустеет
    while (!queue->empty()) {
        // Извлечение элемента
        cout &lt;&lt; queue->pop() &lt;&lt; " gets their turn!" &lt;&lt; endl;
        if (!queue->empty()) {
            // Если очередь не пуста, смотрим на следующий элемент, но не извлекаем его
            cout &lt;&lt; queue->peek() &lt;&lt; " will be next." &lt;&lt; endl;
        }
    }
    delete queue;
    cout &lt;&lt; "We're done now!" &lt;&lt; endl;
}
  </code></pre>
  <p>
    Двусвязный список, двусторонную очередь и циклические версии всего этого,
    надеюсь, сможете сделать сами. Эта статья, в первую очередь, поясняет
    принципы, на которых это основано и показывает пример +- грамотно составленного
    кода.
  </p>
</section>
{% endblock %}